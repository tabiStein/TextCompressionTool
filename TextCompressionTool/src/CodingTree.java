/*
 * Tabi Stein
 * TCSS 342 C - Winter 2015
 * CompressedLiterature2
 */

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StringReader;
import java.util.Set;

/**
 * An implementation of a huffman tree to encode the message passed into the constructor.
 * Also contains static methods for decoding any message generated by an object of this
 * class by providing the code table, and regenerating a code table from a code file.
 * @author Tabi Stein
 * @version 1.0
 */
public class CodingTree {

	/**The fixed capacity for the MyHashTables used in counting words and storing codes.*/
	private static final int TABLE_CAPACITY = 32768;
	//private static final int TABLE_CAPACITY = 200; //for testing
	
	public static final String CHARSET = "UTF8";
	
	/**Holds a String of 1s and 0s using the codes generated by this CodingTree.*/
	public final String bits;
	
	/**Relates each Unicode character to its translation via this CodingTree.*/
	private MyHashTable<String, String> myTable;
	
	/**3 is code for end of file character*/
	private final LeafNode eofLeaf = new LeafNode("" + (char) 3, 1); 
	
	/**
	 * Constructs a new CodingTree using the given message. Compresses the message and
	 * creates a code map for decoding.
	 * @param message the String to compress.
	 */
	public CodingTree(String message) {
		if (message.length() > 0) {
			myTable = new MyHashTable<String, String>(TABLE_CAPACITY);
			calcPriority(message);		
			bits = compress(message);
		} else {
			myTable = null;
			bits = "";
		}
	}
		
	/**
	 * Returns a map relating each character in the message to its encoded counter part 
	 * (in bits).
	 * @return the map of codes
	 */
	public MyHashTable<String, String> codes() {
		return myTable;
	}
	
	/**
	 * Adds each String found in myMessage to a MyHashTable as the key to the
	 * value storing the number of times the String appears. Then creates a
	 * LeafNode for each key, storing its number of appearances as a weight.
	 * Then adds all these leaves to a priority queue. Passes this priority
	 * queue on to the tree building step.
	 */
	private void calcPriority(String message) {
		StringReader reader = new StringReader(message);
		MyHashTable<String, Integer> allWords = 
									new MyHashTable<String, Integer>(TABLE_CAPACITY);
		try {
			StringBuilder keyBuilder = new StringBuilder();
			int nextChar = reader.read();
			
			//Keep reading character by character until -1, end of myMessage, is reached
			while (nextChar > -1) {						
				if (inWordSet(nextChar)) { //Determine whether to continue or start a new String				
					keyBuilder.append((char) nextChar);
				} else { //start a new String
					if (keyBuilder.length() > 0) { //Check for a String under development
						String newKey = keyBuilder.toString(); 
						addOrIncrement(newKey, allWords); //Add or increment the key
						keyBuilder = new StringBuilder();
					}
					addOrIncrement("" + (char) nextChar, allWords);					
				}
				
				nextChar = reader.read();
			}
			//Salvage any remaining key being developed
			if (keyBuilder.length() > 0) {
				String newKey = keyBuilder.toString(); 
				addOrIncrement(newKey, allWords); //Add or increment the key
			}
		} catch (IOException e) {
			e.printStackTrace();
		}	
		
		//Add leaves holding all words to a priority queue weighted by their number of
		//occurences
		MyPriorityQueue<Node> pq = new MyPriorityQueue<Node>();
		
		for (String key : allWords.keySet()) {			
			LeafNode leaf = new LeafNode(key, allWords.get(key));
			pq.add(leaf);
		}	
		
		pq.add(eofLeaf);		
		
		buildTree(pq);
	}

	/**
	 * Determines whether the given character is in the set {0,...,9,A,...,Z,a,...,z,’,-}
	 * which comprises words of multiple characters.
	 * @param nextChar the character to check
	 * @return inWordSet true if character is in set; false otherwise
	 */
	private boolean inWordSet(int nextChar) {
		boolean inWordSet = nextChar == '\'' || nextChar == '-';
		if (!inWordSet) { //Determine if member of alphabet
			if (nextChar >= 'A') { //At least A
				inWordSet = nextChar <= 'Z';
				if (!inWordSet) {
					inWordSet = nextChar >= 'a';
					if (inWordSet) {
						inWordSet = nextChar <= 'z';
					}
				}
			}
		}
		return inWordSet;
	}
	
	/**
	 * Puts the given key in the given hash table if not already present, or increments
	 * the key's value if it already contains the key.
	 * @param theKey the key to check
	 * @param theTable the MyHashTable to add to
	 */
	private void addOrIncrement(String theKey, MyHashTable<String, Integer> theTable) {
		Integer occurences = theTable.get(theKey);
		//Check if key is already in table
		if (occurences != null) {
			occurences++;
		} else {
			occurences = 1;
		}
		theTable.put(theKey, occurences);
	}
	
	
	/**
	 * Accepts a MyPriorityQueue of Nodes weighted by the frequency their words appear in
	 * MyMessage. Grabs the two highest priority (i.e. Nodes holding least frequently
	 * occuring characters) Nodes out of the priority queue, setting them as the
	 * children of a new InternalNode, and adding them back into the priority
	 * queue, until there is only one node left in the priority queue.
	 * 
	 * @param pq
	 *            the MyPriorityQueue holding the LeafNodes.
	 */
	private void buildTree(MyPriorityQueue<Node> pq) {
		while (pq.size() > 1) { //i.e. at least 2
			Node first = pq.remove();
			Node second = pq.remove();
			InternalNode parent = new InternalNode(first, second);
			pq.add(parent);
		}
		InternalNode head;
		Node last = pq.remove();
		if (last instanceof LeafNode) {
			head = new InternalNode(last, null);
		} else {
			head = (InternalNode) last;
		}
		
		buildTable(head, "");
	}
	
	
	
	/**
	 * A recursive method that builds myTable by navigating the tree in an
	 * in-order manner to determine the codes for each LeafNode.
	 * 
	 * @param parent
	 *            an InteralNode who recursively checks his children until he
	 *            gets to a LeafNode.
	 * @param pathSoFar
	 *            a String holding the path taken to get to parent
	 */
	private void buildTable(InternalNode parent, String pathSoFar) {
		//try left
		if (parent.lft instanceof LeafNode) {
			//Found a leaf, add it to map with its code
			LeafNode lftLeaf = (LeafNode) parent.lft;
			myTable.put(lftLeaf.myWord, pathSoFar + "0");
		} else if (parent.lft instanceof InternalNode) {
			//Not a leaf, keep going
			InternalNode lftNode = (InternalNode) parent.lft;
			buildTable(lftNode, pathSoFar + "0");
		}
		//try right
		if (parent.rgt instanceof LeafNode) {
			LeafNode rgtLeaf = (LeafNode) parent.rgt;
			myTable.put(rgtLeaf.myWord, pathSoFar + "1");
		} else if (parent.rgt instanceof InternalNode) {
			InternalNode rgtNode = (InternalNode) parent.rgt;
			buildTable(rgtNode, pathSoFar + "1");
		}
	}
	
	/**
	 * Goes through the given message, matching each word to its code in myTable.
	 * Reads each character, determining if it's a member of the set of characters
	 * that can belong to a larger cluster of characters; if so, it adds the character to
	 * the growing word. Otherwise, it writes the code for the the current word to the
	 * String of 1s and 0s, which is then returned.
	 * @return the 1s and 0s representing the compressed String of myMessage.
	 */
	private String compress(String message) {
		
		StringReader reader = new StringReader(message);
		//Builds the string of 1s and 0s
		StringBuilder theBits = new StringBuilder();
		
		try {
			StringBuilder currentWord = new StringBuilder();
			int nextChar = reader.read(); //read first character from file
			while (nextChar > -1) {
				if (inWordSet(nextChar)) {
					currentWord.append((char) nextChar);
				} else {
					if (currentWord.length() > 0) {
						String bitString = myTable.get(currentWord.toString());
						if (bitString != null) {
							theBits.append(bitString);
						}
						currentWord = new StringBuilder();
					}					
					String bitString = myTable.get("" + (char) nextChar);
					if (bitString != null) {
						theBits.append(bitString);
					}
				}
				nextChar = reader.read();
			}
		
			//Add the rest of currentWord to theBits as needed
			if (currentWord.length() > 0) {
				String bitString = myTable.get(currentWord.toString());
				if (bitString != null) {
					theBits.append(bitString);
				}
			}
			
			//Add end of file marker to theBits
			if (myTable.containsKey(eofLeaf.myWord)) {
				theBits.append(myTable.get(eofLeaf.myWord));
			}

			 
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		reader.close();
		return theBits.toString();
	}
	
	/**
	 * Reads from a file to build a MyHashTable of word keys to bit string values. Each 
	 * entry must be formatted as such: (key=value).
	 * @param codeFile
	 * @return
	 */
	public static MyHashTable<String, String> codesFromFile(File codeFile) {
		MyHashTable<String, String> codeTable = new MyHashTable<String, String>(TABLE_CAPACITY);
		
		/*Was tricky to implement as both BufferedReader.readLine() and Scanner.nextLine()
		 *hop over every \n and \r they find, including those that are keys. Ended up
		 *using the idea of state transitions from finite state machines to check for open
		 *paren, equals, and close paren. 
		 */
		try {
			BufferedReader reader = new BufferedReader(
					new InputStreamReader(
							new FileInputStream(codeFile), CodingTree.CHARSET));
			StringBuilder lineBuilder = new StringBuilder();
			int nextChar = reader.read();
			int currentState = 0; //must be 2 and read a close paren for line to be complete
			int indexAfterFirstParen = 0;
			int equalsIndex = 0;
			while (nextChar >= 0) {
				lineBuilder.append((char) nextChar);
				if (nextChar == '(' && currentState == 0) {
					indexAfterFirstParen = lineBuilder.length();
					currentState++;
				}
				if (nextChar == '=' && currentState >= 1) { //>= in case there are multiple equals signs
					equalsIndex = lineBuilder.length() -1;
					currentState = 2;
				}
				if (nextChar == ')' && currentState == 2) {
					String line = lineBuilder.toString();
					String key = line.substring(indexAfterFirstParen, equalsIndex);
					String value = line.substring(equalsIndex + 1, line.length() - 1);
					codeTable.put(key, value);
					lineBuilder = new StringBuilder();
					currentState = 0;
					indexAfterFirstParen = 0;
					equalsIndex = 0;
				}
				nextChar = reader.read();
			}
			reader.close();

		} catch (IOException e) {
			e.printStackTrace();
		} 
		
		
		return codeTable;
	}
	
	/**
	 * Accepts a MyHashTable of codes and a String of 1s and 0s, decoding them using the 
	 * huffman tree generated by the table. 
	 * @param theBits a String of 1s and 0s
	 * @param codes a MyHashTable holding the word and code mappings to decode the bits.
	 * @return the decoded text
	 */
	public static String decode(String theBits, MyHashTable<String, String> codes) {
		InternalNode root = reconstructTree(codes);
		
		StringReader sr = new StringReader(theBits);
		StringBuilder sb = new StringBuilder();
		Node currentNode = root;
		try {
		int nextBit = sr.read();
		while (nextBit > -1) {
			if (currentNode instanceof LeafNode) {
				LeafNode leaf = (LeafNode) currentNode;
				if (leaf.myWord.equals("" + (char) 3)) { //Check for end of file
					break;
				} else {
					sb.append(leaf.myWord);
					currentNode = root; //go back to root
				}
			}	

			InternalNode parent = (InternalNode) currentNode;
			if (nextBit == 49) {
				//go right
				if (parent.rgt != null) {
					currentNode = parent.rgt;
				} else {
					currentNode = root;
				}
			} else {
				//go left	
				if (parent.lft != null) {
					currentNode = parent.lft;
				} else {
					currentNode = root;
				}
			}
			nextBit = sr.read();
		}	
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		return sb.toString();
	}
	
	/**
	 * Constructs a huffman tree from the given MyHashTable of codes, returning the root
	 * node.
	 * @param codes
	 * @return InternalNode the root of the Huffman tree
	 */
	private static InternalNode reconstructTree(MyHashTable<String, String> codes) {
		CodingTree dummyTree = new CodingTree("");
		Set<String> codeSet = codes.keySet();
		InternalNode root = dummyTree.new InternalNode();
		for (String s : codeSet) {
			InternalNode currentNode = root;
			char[] bitArr = codes.get(s).toCharArray();
			for (int i = 0; i < bitArr.length - 1; i++) { //look at all bits except last one
				if (bitArr[i] == '1') { //go right
					//check if currentNode has a right child, adding as necessary
					if (currentNode.rgt == null) {
						currentNode.rgt = dummyTree.new InternalNode();						
					}
					currentNode = (InternalNode) currentNode.rgt;
				} else { //go left
					if (currentNode.lft == null) {
						currentNode.lft = dummyTree.new InternalNode();						
					}
					currentNode = (InternalNode) currentNode.lft;
				}
			}
			//Now look at final bit to decide where to put word
				if (bitArr[bitArr.length - 1] == '1') { //go right
					currentNode.rgt = dummyTree.new LeafNode(s, 0);
				} else { //go left
					currentNode.lft = dummyTree.new LeafNode(s, 0);
				}
		}
		return root;
	}
	
	
	/**
	 * A weighted, childless Node comparable to other Nodes based on weight.
	 */
	private class Node implements Comparable<Node>{
		
		final int weight;
		
		Node(int theWeight) {
			weight = theWeight;
		}

		@Override
		public int compareTo(Node other) {
			return weight - other.weight;
		}
		
	}
	
	/**
	 * A childless Node holding a char.
	 * @author Tabi
	 *
	 */
	private class LeafNode extends Node {
		
		final String myWord;
		
		LeafNode(String theWord, int theWeight) {
			super(theWeight);
			myWord = theWord;
		}
		
		@Override
		public String toString() {
			return "\"" + myWord + "\", " + weight;
		}
	}
	
	/**
	 * A Node with two children.
	 * @author Tabi
	 */
	private class InternalNode extends Node {
		
		private Node lft;
		private Node rgt;
		
		InternalNode(Node theLeft, Node theRight) {
			super(theLeft.weight + theRight.weight);
			lft = theLeft;
			rgt = theRight;
		}
		
		/**
		 * Constructs a new InternalNode with null children.
		 */
		InternalNode() {
			super(0);
			lft = null;
			rgt = null;
		}
		
		@Override
		public String toString() {
			return "[" + lft.toString() + "; " + rgt.toString() + "]" + ", " + weight;
		}
		
	}
	
}
